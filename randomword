#!/usr/bin/perl
use strict;
use Getopt::Std;

my $usage = <<_EOF_;
usage: randomword [options]
       -b <number>  %chance of terminating sentence with !
       -c <number>  Minimum words between commas
       -C <number>  Maximum words between commas
       -D <number>  %chance of comma after word
       -d <file>    Dictionary file
       -l <number>  Number of lines (if set, -n is ignored)
       -m <number>  Minimum word length
       -M <number>  Maximum word length
       -n <number>  Number of words
       -p           Add punctuation
       -q <number>  %chance of terminating sentence with ?
       -s <number>  %chance of ending sentence after each word
       -w <number>  Format as paragraph with given width 
_EOF_

# Based on extensive linguistic research {d}
my $sent_min = 4;
my $sent_max = 20;

exit (main() ? 0 : 1);

sub main {
    my %opt;
    if (not getopts('b:c:C:d:D:l:m:M:n:pq:s:w:?!', \%opt) or @ARGV > 0) {
        print $usage;
        return 0;
    }
    my $wpc_min       = $opt{c} ? $opt{c} : 4;
    my $wpc_max       = $opt{C} ? $opt{C} : 25;
    my $wpc_pct       = $opt{D} ? $opt{D} : 20;
    my $word_file     = $opt{d} ? $opt{d} : '/usr/share/dict/words';
    my $num_lines     = $opt{l} ? $opt{l} : -1;
    my $wordlen_min   = $opt{m} ? $opt{m} : 0;
    my $wordlen_max   = $opt{M} ? $opt{M} : 999;
    my $num_words     = $opt{l} ? -1 : $opt{n} ? $opt{n} : 1;
    my $endsent_pct   = $opt{'s'} ? $opt{'s'} : 10;
    my $para_width    = $opt{w} ? $opt{w} : 0;
    my $punc          = $opt{P};
    my $quest_pct     = $opt{'q'} ? $opt{'q'} : 5;
    my $exclam_pct    = $opt{'b'} ? $opt{'b'} : 2;

    my $words = all_words($word_file, $wordlen_min, $wordlen_max);
    my $line = '';
    my $sent = 0; # words in current sentence (unrelated to lines)
    my $wsc = 0; # words since last comma
    my $cap = $punc; # capitalize next word
    my $printed_lines = 0;
    for (my $gen_words = 0; $gen_words < $num_words or $num_words == -1; ++$gen_words) {
        my $word = $$words[int rand @$words];
        if ($cap) {
            $word = ucfirst $word;
            $cap = 0;
        }
        my $sep = (length($line) > 0) ? ' ' : '';
        if (length($line) + length($sep) + length($word) > $para_width) {
            if ($line) {
                print $line, "\n";
                ++$printed_lines;
                if ($num_lines != -1 and $printed_lines >= $num_lines) {
                    $line = '';
                    last;
                }
            }
            $line = $word;
        } else {
            $line .= $sep if $line;
            $line .= $word;
        }
        if ($punc) {
            if (++$wsc >= $wpc_max or ($wsc >= $wpc_min and rand(100) < $wpc_pct)) {
                $line .= ',';
                $wsc = 0;
            } elsif (++$sent >= $sent_max or ($sent >= $sent_min and rand(100) < $endsent_pct)) {
                my $pct = rand(100);
                $line .= ($pct < $quest_pct) ? '?' : ($pct < $quest_pct+$exclam_pct) ? '!' : '.';
                $sent = 0;
                $cap = 1;
            }
        }
    }
    if ($line) {
        print $line;
        print "." if $punc;
        print "\n";
    }
    return 1;
}

sub all_words {
    my ($word_file, $wordlen_min, $wordlen_max) = @_;
    my $wf;
    open $wf, $word_file or die "cannot open $word_file\n";
    my @words;
    while (<$wf>) {
        chomp;
        push @words, $_ if length($_) >= $wordlen_min and length($_) <= $wordlen_max;
    }
    close $wf;
    return \@words;
}
